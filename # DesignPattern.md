# 工厂模式
```cpp
是一种创建型设计模式，它提供了一种创建对象的方式，将对象的创建过程与使用过程分离，从而提高代码的可扩展性和可维护性。
优点：
1. 客户端不需要知道具体的产品实现，只需要知道产品的抽象接口和如何获取产品的方式。客户端只需要使用工厂接口提供
的方法获取产品即可，而不需要知道产品的具体实现细节。
2. 可以根据需求变化而动态地创建不同的产品对象，可以很好地应对复杂的产品类层次结构和变化频繁的需求变化，从而提高代码的
可维护性和可扩展性。

缺点：
1. 增加了代码的复杂性：引入工厂模式后，需要编写额外的工厂类和产品类，这增加了代码的复杂性，使得代码更难以理解和维护。

2. 增加了系统的开销：在工厂模式中，需要创建工厂类和产品类的实例，这会增加系统的开销。

3. 不易于扩展：虽然工厂模式可以增加系统的灵活性和可扩展性，但是如果要添加新的产品类，需要修改工厂类的代码，这可能会
破坏原有的代码结构，不易于扩展。

4. 违反了开放-封闭原则：开放-封闭原则是面向对象设计中的一个重要原则，它要求系统应该对扩展开放，对修改关闭。工厂模式在
添加新产品类时需要修改工厂类的代码，违反了这一原则。

5. 难以进行单元测试：由于工厂模式中的对象创建是通过工厂类来实现的，这使得单元测试变得更加困难，因为测试需要同时测试工
厂类和产品类。
```
## 简单工厂模式
```cpp
静态工厂方法模式，是一种常用的工厂模式。简单工厂模式定义了一个工厂类，该类负责创建多个不同类型的产品类的实例，客户端
只需要提供给工厂类相应的参数，工厂类就可以根据参数的不同来创建不同的产品实例。

工厂类中通常使用static将创建具体产品的函数声明为静态函数，它与类的实例化对象无关，可以直接通过类名来调用，因为客户端
通过工厂类的静态方法来创建产品对象，而不需要先实例化工厂类。因此，将 createProduct 方法声明为静态方法，可以避免客户
端在使用工厂类时需要创建工厂类对象的麻烦。

适用于创建对象较少的场景，对于需要创建的产品类较多的场景，工厂方法模式或抽象工厂模式更适合。
```
```cpp
优点：
1. 可以将对象的创建过程进行封装，使得客户端不需要知道具体的创建过程，从而减少了客户端与具体产品类的耦合。
2. 可以对客户端隐藏具体的产品类，提高了系统的安全性。

缺点：
1. 每次添加新的产品类时都需要修改工厂类的代码，违反了开放-封闭原则。
2. 由于工厂类集中了所有产品的创建逻辑，代码量可能会很大，影响代码的可读性和可维护性。
```
```cpp
核心结构：
  Product：抽象产品类，定义了产品的属性和方法。
  ConcreteProduct：具体产品类，实现了Product接口。
  Factory：工厂类，负责创建具体的产品类实例。
  Client：客户端类，通过工厂类来创建具体的产品实例。
```
## 工厂方法模式
```cpp
是一种创建型设计模式，它定义了一个用于创建对象的接口，但是由子类决定要实例化的类是哪一个(将对象的创建延迟到子类中进行)。

工厂方法模式的核心是工厂接口和工厂子类，其中工厂接口定义了一个用于创建对象的方法，而工厂子类实现了这个方法，并根据实际需
求创建具体的对象。这种方式能够有效地将对象的创建和使用分离开来，使得程序更加灵活和可扩展。
```
```cpp
优点：
1. 遵循了开闭原则，可以很容易地增加新产品或者修改现有产品的实现，而无需修改客户端代码。
2. 将产品的实例化延迟到子类中进行，解耦了客户端和具体产品类的依赖关系，使系统更加灵活。
3. 提供了一种封装产品对象创建过程的方式，使客户端不需要知道产品的具体实现细节，降低了客户端与具体产品之间的耦合度。

缺点：
1. 每增加一个具体产品类，就需要增加一个对应的具体工厂类，导致类的个数成倍增加，增加了系统的复杂度。
2. 工厂方法模式中的抽象产品类和具体产品类都需要客户端知道或者了解，这增加了客户端的学习和理解成本。
```
```cpp
核心结构：
  Product：抽象产品，定义了产品的公共接口。
  ConcreteProduct：具体产品，实现了抽象产品接口的具体产品。
  Factory：抽象工厂，定义了工厂的公共接口，用于创建抽象产品。
  ConcreteFactory：具体工厂，实现了抽象工厂接口的具体工厂，用于创建具体产品。
```